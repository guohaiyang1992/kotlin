## **简介**
本篇博客主要是介绍Kotlin语法中的【类和继承】相关的知识，帮助各位更快的掌握Kotlin，如果有疏漏或者错误，请在留言中指正，谢谢。 [系列汇总地址](http://blog.csdn.net/guohaiyang1992/article/details/72615889)

---
## **类**
### **声明类**
Kotlin中使用关键词class 声明类和java中保持一致，代码如下：

```
class Demo{ //class + 类名
    
}
```
类的构成=class +类名+类头（可选）+类体（可选），如果没有类体，括号也可省略
```
class Demo //class + 类名
```
### **主构造函数**
在Kotlin的类中可以有一个主构造函数和多个次构造函数。我们看看什么样的算主构造函数，例子如下：

```
class Demo(){

}
```
看了例子估计心里开始有疑惑了，这和上面的例子有什么不同？？仔细一看还真有不同，多了"（）"，这就声明了一个无参的主构造函数，当然你也可以声明有参数的，如下

```
class Demo(name: String){

}
```
主构造函数只是类头的一部分，还有一个可选关键词--**constructor**，当主构造函数想声明为非public 类型的时候，需要使用该关键词其他时候可以省略，例如：

```
class Demo private constructor(name: String){

}
```
这种情况一般是在写单例的时候会用到。

构造函数都有了，我们可以愉快的做些初始化了，但是但是要注意，**主构造函数内不能包含任何代码。** 这个时候我们需要使用另一个关键词 `init`,使用`init` 代码块进行初始化代码即可，如下：

```
class Demo private constructor(name: String) {
    init {//init代码块
        println("测试输出")
    }
}
```
上面的代码中`name` 可以直接使用在 **`init`代码块内和类体内声明的属性初始化中使用**，只有这两种情况，代码如下

```
class Demo (name: String) {
    init {
        println("测试输出"+name) //在此处使用可以
    }
    var nameTest=name //此处给nameTest赋值可以，但不可以单独使用
}
```
当然我们可以让上面的`name` 有更多的用途怎么办呢？可以这样写：

```
class Demo(var name: String) { //此处加入 var关键词
    init {
        println("测试输出" + name)
    }

    var nameTest = name

    fun printTest() { //方法内也可使用了
        println(name)
    }
}
```
不仅可以使用`var`关键词，还可以使用val，具体的差别之前我们说过，再次不再赘述。
使用该关键词后，name就等同于是该类的成员变量，就等同于你直接声明在类中。
对于Kotlin来说还有个好用的地方，就是你声明的类中变量不需要写get/set方法，默认就会有，可以直接用。

### **次构造函数**
Kotlin中类也可以声明前缀有 constructor 的**次构造函数**,如下：

```
class Demo { //有个默认的无参主构造函数
  constructor(){// 有个无参次构造函数

  }
}
```
如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数 用 this 关键字即可，如下：

```
class Demo() { //没参数的主构造函数
    constructor(name: String) : this() { //次构造函数委托给
    }
}
```

仔细的筒子估计会发现，你刚才的次构造函数也没写this 啊，怎么可以，后面又说需要this，我来帮助大家理解一下，上面写法的含义，代码如下：


```
class Demo {
    init {
    println("demo")
    }

    constructor(name: String):this() {
        println("demos")
    }
    constructor(){
        println("demossss")

    }
}
```

上面的例子之所以不需要写，是因为 **系统会默认委托给无参的未重写过的默认主构造函数**，注意是未重写过的，还有一点，如果写了this() 会导致循环调用，相当于调用自己。
如下：


```
public class demo {
    public demo() { //此处代表的是次构造函数，java中会导致原本的默认构造函数不创建，Kotlin中次构造并不会影响主构造的创建
	this(); //如果这里写这个就会导致这个问题
    }

    public demo(String name) {
        this();
    }
}
```
从调用角度看，你当前能调用到的只有无参的次构造函数，无参数的主构造函数调用不到。

我为什么会说，**系统会默认调用无参的未重写过的默认主构造函数**，因为无论你如何重写次构造函数，而不改写主构造函数，甚至写一个无参数的次构造函数，最终 `init` 代码块的内容仍被执行了，我们也说过它执行在主构造函数，所以得出上面的结论。Kotlin中只有重写主构造函数，才会真正的影响到默认的无参主构造函数，否则即使次构造函数生成一个一样的构造函数仍然不会影响。
接着我们看下面的情况，代码如下：

```
class Demo(){ //此处重写默认的无参主构造函数
    init {
    println("demo")
    }
	
	//由于不是默认无参数主构造函数，所此处需要写this(),委托给重写后的主构造函数
    constructor(name: String):this() {
        println("demos")
    }
    
	constructor(name:String,age:Int):this(name){ //间接的委托给主构造函数
        println("demoss")

    }
    
    //由于已经重写无参的构造函数了，此处的不能再重写，优先级低
//    constructor(){
//        println("demossss")
//
//    }
}
```
此时由于重写了默认的无参主构造函数，所以后续的需要委托给主构造函数的写法就发生了变化，且原本可以声明的无参次构造函数也不允许再次声明了，我们看一下不重写的是什么样子的：

```
class Demo {//没重写
    init {
        println("demo")
    }

    constructor(name: String)  { //不需要this()
        println("demos")
    }

}
```
通过上方的各种对比和例子我们对类的构造函数有了大概的了解，我们为了方便理解在这里总结一波，还有不明白的多看看例子：

 - 类只有一个主构造函数，但可以有一个或多个次构造函数

 - 次构造函数需要委托给主构造函数，可以通过直接或者间接的方式

 - 在声明期间，以主构造函数为主，如果主构造函数**重写**了对应的构造方法，次构造函数不能用重复的出现对应的构造函数，上面有例子说明。

 - 在调用期间，以次构造函数为主，如果未重写主构造函数，默认会有一个无参的主构造函数，如果重写一个无参次构造函数，则可调用的只有次构造函数。
 
注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。
```
class Customer(val customerName: String = "")
```
###**创建类的实例**

要创建一个类的实例，我们就像普通函数一样调用构造函数：

```
val invoice = Invoice()
val customer = Customer("Joe Smith")
//注意 Kotlin 并没有 new 关键字。
```
## **继承**
在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类：

```
class Example // 从 Any 隐式继承
```
Any 不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。 更多细节请查阅Java互操作性部分。

要声明一个显式的超类型，我们把类型放到类头的冒号之后：

```
open class A(p: Int) //注意此处的 open 关键词

class B(p: Int) : Base(p) //使用" ："
```
**对于继承的类来说，它仍需满足之前类中主次构造函数的规定，还需满足继承类委托给被继承类的主构造函数（保证对应类的init模块都能运行的关键），此处的被委托的主构造函数如果是无参构造函数，可以省略不写**

下面我们分两种类型去分别讲解，首先是未修改默认的主构造函数的情况：
我们先看一下被继承类：

```
open class BB { //未重写默主构造

    constructor(name: String) {
        println(name + "---BB")
    }


    constructor() {
        println(".....---BB")

    }
}
```
继承类：

```
class testA : BB { //此处testA也没重写主构造
    constructor(name: String) : super(name) {//--    1)
        println("A---" + name)
    }

    constructor() {//--  2)
        println("A---" + "ss")
    }
}
```
位置1处的构造函数，因为未重写主构造，所以本类的委托完成，所以只需委托父类即可，即可满足上面说的要求。

位置2处的构造函数，因为未重写主构造，所以本类的委托完成，又因为默认是委托父类的无参主构造函数（系统默认的或者重写的都满足），所以满足上面说的要求。

我们做下改动，将B 改动如下：

```
open class BB() {//重写默认主构造

    constructor(name: String):this() { //手动委托主构造
        println(name + "---BB")
    }


//    constructor() { //根据主次函数关系，此处无法存在
//        println(".....---BB")
//
//    }
}
```
这时候我们的继承类如何写呢？

```
class testA : BB {
    constructor(name: String) : super(name) {
        println("A---" + name)
    }

    constructor() {
        println("A---" + "ss")
    }
}
```
可以看到代码是没变化的，也就是说，只要是被继承类的主构造函数，是无参的，无论是默认还是重写都可以省略不写，当然也可以写上

```
class testA : BB {
    constructor(name: String) : super(name) {//可以选择不同的父类的主构造函数进行委托
        println("A---" + name)
    }

    constructor():super() {//无参的委托
        println("A---" + "ss")
    }
}
```
下面我们将一下修改默认主构造函数的情况

```
class testB(name: String) : BB(name) { //此处testB重写了默认主构造，所以此处B一定需要用主构造函数（直接或间接的）
    init {
        println(name + "99ss...---B")
    }

    constructor(name: String, age: Int) : this(name) {
        println(name + "...---B")
    }
}
```

也可以这样写：

```
class testB(name: String) : BB() { //此处必须有"（）"
    init {
        println(name + "99ss...---B")
    }

    constructor(name: String, age: Int) : this(name) {  //此处不能使用super了，不能重复委托父类，主构造函数已经委托过了
        println(name + "...---B")
    }
}
```

下面我们总结一波：

 - 如果继承的类重写了默认主构造函数，此时必须用基类的主构造函数初始化（直接或间接）

 - 如果继承的类没重写默认的主构造函数，此时可以使用super关键词初始化，我们也说过，未重写的的默认主构造函数，次构造函数都会委托给它，所以本类内也满足了委托条件，对于类外，也委托了被继承类的主构造方法，完成了两个类的条件
